use std::num::NonZeroU32;

use crate::{Attribute, ValueType};

/// Identifier of a node in a graph.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct NodeId(NonZeroU32);

impl NodeId {
    /// Create a new node identifier.
    pub fn new(id: NonZeroU32) -> Self {
        Self(id)
    }

    /// Get the one-based node index.
    pub fn id(&self) -> NonZeroU32 {
        self.0
    }

    /// Get the zero-based index of the node in the underlying graph node array.
    pub fn index(&self) -> usize {
        (self.0.get() - 1) as usize
    }
}

/// Identifier of a slot in a graph.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct SlotId(NonZeroU32);

impl SlotId {
    /// Create a new slot identifier.
    pub fn new(id: NonZeroU32) -> Self {
        Self(id)
    }

    /// Get the one-based slot index.
    pub fn id(&self) -> NonZeroU32 {
        self.0
    }

    /// Get the zero-based index of the slot in the underlying graph slot array.
    pub fn index(&self) -> usize {
        (self.0.get() - 1) as usize
    }
}

/// Node slot direction.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum SlotDir {
    /// Input slot receiving data from outside the node.
    Input,
    /// Output slot providing data generated by the node.
    Output,
}

/// Definition of a slot of a node.
#[derive(Debug, Clone)]
pub struct SlotDef {
    /// Slot name.
    name: String,
    /// Slot direaction.
    dir: SlotDir,
    /// Type of values accepted by the slot.
    value_type: ValueType,
}

impl SlotDef {
    /// Create a new input slot.
    pub fn input(name: impl Into<String>, value_type: ValueType) -> Self {
        Self {
            name: name.into(),
            dir: SlotDir::Input,
            value_type,
        }
    }

    /// Create a new output slot.
    pub fn output(name: impl Into<String>, value_type: ValueType) -> Self {
        Self {
            name: name.into(),
            dir: SlotDir::Output,
            value_type,
        }
    }

    /// Get the slot name.
    pub fn name(&self) -> &str {
        &self.name
    }

    /// Get the slot direction.
    pub fn dir(&self) -> SlotDir {
        self.dir
    }

    /// Get the slot value type.
    pub fn value_type(&self) -> ValueType {
        self.value_type
    }
}

/// Single slot of a node.
#[derive(Debug, Clone)]
pub struct Slot {
    /// Owner node identifier.
    node_id: NodeId,
    /// Identifier.
    id: SlotId,
    /// Slot definition.
    def: SlotDef,
    /// Linked slots.
    linked_slots: Vec<SlotId>,
}

impl Slot {
    /// Create a new slot.
    pub fn new(node_id: NodeId, slot_id: SlotId, slot_def: SlotDef) -> Self {
        Slot {
            node_id,
            id: slot_id,
            def: slot_def,
            linked_slots: vec![],
        }
    }

    /// Get the node identifier of the node this slot is from.
    pub fn node_id(&self) -> NodeId {
        self.node_id
    }

    /// Get the slot identifier.
    pub fn id(&self) -> SlotId {
        self.id
    }

    /// Get the slot definition.
    pub fn def(&self) -> &SlotDef {
        &self.def
    }

    /// Get the slot direction.
    pub fn dir(&self) -> SlotDir {
        self.def.dir()
    }

    /// Check if this slot is an input slot.
    ///
    /// This is a convenience helper for `self.dir() == SlotDir::Input`.
    pub fn is_input(&self) -> bool {
        self.dir() == SlotDir::Input
    }

    /// Check if this slot is an output slot.
    ///
    /// This is a convenience helper for `self.dir() == SlotDir::Output`.
    pub fn is_output(&self) -> bool {
        self.dir() == SlotDir::Output
    }

    /// Link this output slot to an input slot.
    ///
    /// # Panic
    ///
    /// Panics if this slot's direction is `SlotDir::Input`.
    fn link_to(&mut self, input: SlotId) {
        assert!(self.is_output());
        if !self.linked_slots.contains(&input) {
            self.linked_slots.push(input);
        }
    }

    fn unlink_from(&mut self, input: SlotId) -> bool {
        assert!(self.is_output());
        if let Some(index) = self.linked_slots.iter().position(|&s| s == input) {
            self.linked_slots.remove(index);
            true
        } else {
            false
        }
    }

    fn link_input(&mut self, output: SlotId) {
        assert!(self.is_input());
        if self.linked_slots.is_empty() {
            self.linked_slots.push(output);
        } else {
            self.linked_slots[0] = output;
        }
    }

    fn unlink_input(&mut self) {
        assert!(self.is_input());
        self.linked_slots.clear();
    }
}

/// Effect graph.
pub struct Graph {
    nodes: Vec<Box<dyn Node>>,
    slots: Vec<Slot>,
}

impl std::fmt::Debug for Graph {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Graph").field("slots", &self.slots).finish()
    }
}

impl Graph {
    /// Create a new graph.
    pub fn new() -> Self {
        Self {
            nodes: vec![],
            slots: vec![],
        }
    }

    /// Add a node to the graph.
    pub fn add_node(&mut self, node: Box<dyn Node>) -> NodeId {
        let index = self.nodes.len() as u32;
        let node_id = NodeId::new(NonZeroU32::new(index + 1).unwrap());

        for slot_def in node.slots() {
            let slot_id = SlotId::new(NonZeroU32::new(self.slots.len() as u32 + 1).unwrap());
            let slot = Slot::new(node_id, slot_id, slot_def.clone());
            self.slots.push(slot);
        }

        self.nodes.push(node);

        node_id
    }

    /// Link an output slot of a node to an input slot of another node.
    pub fn link(&mut self, output: SlotId, input: SlotId) {
        let out_slot = self.get_slot_mut(output);
        assert!(out_slot.is_output());
        out_slot.link_to(input);

        let in_slot = self.get_slot_mut(input);
        assert!(in_slot.is_input());
        in_slot.link_input(output);
    }

    /// Unlink an output slot of a node from an input slot of another node.
    pub fn unlink(&mut self, output: SlotId, input: SlotId) {
        let out_slot = self.get_slot_mut(output);
        assert!(out_slot.is_output());
        if out_slot.unlink_from(input) {
            let in_slot = self.get_slot_mut(input);
            assert!(in_slot.is_input());
            in_slot.unlink_input();
        }
    }

    /// Unlink all remote slots from a given slot.
    pub fn unlink_all(&mut self, slot_id: SlotId) {
        let slot = self.get_slot_mut(slot_id);
        let linked_slots = std::mem::take(&mut slot.linked_slots);
        for remote_id in &linked_slots {
            let remote_slot = self.get_slot_mut(*remote_id);
            if remote_slot.is_input() {
                remote_slot.unlink_input();
            } else {
                remote_slot.unlink_from(slot_id);
            }
        }
    }

    /// Get all slots of a node.
    pub fn slots(&self, node_id: NodeId) -> Vec<SlotId> {
        self.slots
            .iter()
            .filter_map(|s| {
                if s.node_id() == node_id {
                    Some(s.id())
                } else {
                    None
                }
            })
            .collect()
    }

    /// Get all input slots of a node.
    pub fn input_slots(&self, node_id: NodeId) -> Vec<SlotId> {
        self.slots
            .iter()
            .filter_map(|s| {
                if s.node_id() == node_id && s.is_input() {
                    Some(s.id())
                } else {
                    None
                }
            })
            .collect()
    }

    /// Get all output slots of a node.
    pub fn output_slots(&self, node_id: NodeId) -> Vec<SlotId> {
        self.slots
            .iter()
            .filter_map(|s| {
                if s.node_id() == node_id && s.is_output() {
                    Some(s.id())
                } else {
                    None
                }
            })
            .collect()
    }

    /// Find a slot ID by slot name.
    pub fn get_slot_id<'a, 'b: 'a, S: Into<&'b str>>(&'a self, name: S) -> Option<SlotId> {
        let name = name.into();
        self.slots
            .iter()
            .find(|&s| s.def().name() == name)
            .map(|s| s.id)
    }

    #[allow(dead_code)] // TEMP
    fn get_slot(&self, id: SlotId) -> &Slot {
        let index = id.index();
        assert!(index < self.slots.len());
        &self.slots[index]
    }

    fn get_slot_mut(&mut self, id: SlotId) -> &mut Slot {
        let index = id.index();
        assert!(index < self.slots.len());
        &mut self.slots[index]
    }
}

/// Generic graph node.
pub trait Node {
    ///
    fn parent(&self) -> Option<&dyn Node>;

    ///
    fn children(&self) -> &[&dyn Node];

    /// Get the list of slots of this node.
    ///
    /// The list contains both input and output slots, without any guaranteed order.
    fn slots(&self) -> &[SlotDef];
}

/// Graph node to get or set any single particle attribute.
#[derive(Debug, Clone)]
pub struct AttributeNode {
    /// The attribute to get/set.
    attr: Attribute,
    /// The input and output slots corresponding to the set and get values, respectively.
    slots: [SlotDef; 2],
}

impl AttributeNode {
    /// Create a new attribute node for the given [`Attribute`].
    pub fn new(attr: Attribute) -> Self {
        Self {
            attr,
            slots: [
                SlotDef::input(attr.name(), attr.value_type()),
                SlotDef::output(attr.name(), attr.value_type()),
            ],
        }
    }
}

impl AttributeNode {
    /// Get the attribute this node reads/modifies.
    pub fn attr(&self) -> Attribute {
        self.attr
    }

    /// Set the attribute this node reads/modifies.
    pub fn set_attr(&mut self, attr: Attribute) {
        self.attr = attr;
    }
}

impl Node for AttributeNode {
    fn parent(&self) -> Option<&dyn Node> {
        None
    }

    fn children(&self) -> &[&dyn Node] {
        &[]
    }

    fn slots(&self) -> &[SlotDef] {
        &self.slots
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn graph() {
        let n1 = AttributeNode::new(Attribute::POSITION);
        let n2 = AttributeNode::new(Attribute::POSITION);

        let mut g = Graph::new();
        let nid1 = g.add_node(Box::new(n1));
        let nid2 = g.add_node(Box::new(n2));
        let sid1 = g.output_slots(nid1)[0];
        let sid2 = g.input_slots(nid2)[0];
        g.link(sid1, sid2);
    }
}
